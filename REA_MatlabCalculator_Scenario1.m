clear
%Assumptions
%System modeling for resiliency - Grid outage for full day - only solar and battery system can provide energy
%Season is Winter - Modeled for December 15th
%Location is SLO - Latitude is 35deg
%Modeling with SunPower X-Series Commercial SPR-X22-360-COM
%Modeling with a Mid-day 8h flat load
%Assume SoC on day of outage is 50% - 50% of the battery capacity is reserved for outage scenario

%Inputs: Size of Solar Array (KW), Daily Load (KWh), Critical Load (% of Load)
%Outputs: Approximate #of panels needed, Solar Energy Generated, Minimum Battery Capacity Needed, Battery power rating
%Graphs: Power vs time of 
%% Solar Generation
%% Initialize variables
n = 349;                            %Day number -> using a winter date as worst case scenario
Lat = 35;                           %Latitude
%Lat = input('What is your Latitude?);
dn = 23.45*sind((360*(n-81))/ 365); %Solar Declination

%time references
minutes=0:1:1440;                   
hours = minutes./60;                
hours1 = [0:1:24];
hbeforenoon = 12 - hours;
h_angle = (15 * hbeforenoon);       %Hour Angle

%Altitude Angle
alt = cosd(Lat)*cosd(dn)*cosd(h_angle) + sind(Lat)*sind(dn);
alt_ang = asind(alt);
%Altitude Angle Check
for x=1:1441
    if alt_ang(x) <= 0
        alt_ang(x) = 0;
    else
        alt_ang(x) = alt_ang(x);
    end
end

%Azimuth Angle
az = cosd(dn).*sind(h_angle)./cosd(alt_ang);
az_ang = asind(az);
%Azimuth Angle Check
for x = 1:1441
   if cosd(h_angle(x)) >= tand(dn)/tand(Lat)
    az_ang(x) = az_ang(x);
   else
       if az_ang(x) < 0
           dif = 90 - abs(az_ang(x));
           az_ang(x) = -90 -dif;
       else
           dif = 90 - az_ang(x);
           az_ang(x) = 90 + dif;
       end
   end
end
%% Irradiance Calculations

%Irradiance Beam Calculation
m = 1./sind(alt_ang);                           %Air mass
A = 1160 + 75.*sind((360./365).*(n-275));       %Apparent Extraterrestrial flux
k = 0.174 + 0.035.*sind((360./365).*(n-100));   %Optical Depth
Ib = A.*exp(-k.*m);

%Irradiance beam direct
tilt_angle = Lat;                               %tilt angle of solar panels
%tilt_angle = input('what is the tilt of your panel?');
az_collector = 0;                               %azimuth angle of panel relative due south
                                                %positive in SE direction
                                                %and negative in SW
                                                %direction
%az_collector = input('what is the azimuth angle of your panel?');
C_theta = (cosd(alt_ang).*cosd(az_ang - az_collector).*sind(tilt_angle)) + (sind(alt_ang).*cosd(tilt_angle));
Ibc = Ib.*C_theta; 

%Irradiance beam diffused
C = 0.095+0.04.*sind( (360/365).*(n-100) );     %Sky diffuse factor
Idc = C.*Ib.*( (1+cosd(tilt_angle))./2 );


%Irradiance beam reflected - typically small so will be ignored in
%estimation

%Irradiance Total
Ic = Ibc + Idc;                                 %total estimated irradiance on solar pannel in W/m^2 
%% Total Irradiance Energy

%Trapezoidal Integration
area = trapz(minutes, Ic);                          %W/m^2 * min
tot_energy = area/(1000*60);                        %Total Incident Energy in kWh/m^2 per day
%% Power Loss Estimations
%Losses referenced from ReOpt Lite Maunal (pg.46)
%Soiling - 2%
%Shading - 3%
%Snow - 0%
%Mismatch - 2%
%Wiring - 2%
%Connections - 0.5%
%Light-Induced Degradation - 1.5%
%Nameplate rating - 1%
%Age - 0%
%Availability - 3%
%Total Loss = 14%

%DC-AC conversion efficiency = 96%

TotalLoss = .18;

%Temperature-related loss - ?
%From PVWatts Manual
%Module: Standard (~15% eff) - temp coeff = -0.47%/C
%Module: Premium (~19% eff) - temp coeff = -0.35%/C
%Module: Thin Film (~10% eff) - temp coeff = -0.20%/C
%% Solar Panel Specifications
STC_rating = 360;                               %STC Rating of panels (W)
%STC_rating = input('What is the STC Rating of your panels');

Area_Panels_ft = 17.55;                          %Size of a panel in ft^2
%Area_Panels_ft = input('What is the size of a panel (ft^2)');

Area_Panels_m = Area_Panels_ft/10.764;          %Size of panel in m^2

efficiency = 0.221;                             %Solar Panel Efficieny
%efficiency = input('What is the efficiency of your solar panel?);
%% System Information 
System_Size_kW = input('What is the kW size of the system?');
Num_panels = ceil(System_Size_kW*1000/STC_rating);          %Estimated number of panels for the system
irad_panel = Ic.*efficiency.*Area_Panels_m*(1-TotalLoss);   %Iradiance to usable power per panel (W)
                                                            %W/m^2 * contant * m^2
%% Total Energy
area2 = trapz(minutes, irad_panel);                             %Total Power generated in a day (W*min)
Energy_Generated_panel = area2/(1000*60);                       %Total Energy generated by 1 panel in kWh
Energy_Generated_system = Energy_Generated_panel*Num_panels;    %Total Energy generated by entire system in kWh

%Plot to see irradiance vs. panel vs. full array power
% figure
% plot(minutes, (Ic.*Area_Panels_m)); M1 = "Irradiance";
% hold on
% plot(minutes, irad_panel); M2 = "1 Panel";
% % hold on
% %plot(minutes, irad_panel*Num_panels); M3 = "Full System";
% hold off
% title("Power vs. Time")
% xlabel("Time (minutes)")
% ylabel("Power (W)")
% legend(M1,M2)

area3 = cumtrapz(minutes, irad_panel);
irad_panel_hour = zeros(1,length(hours1));
irad_panel_hour(1) = area3(60);
for i = 1:23
    irad_panel_hour(1+i) = area3(60*(i+1))-area3(60*i);
end
area4 = trapz(hours1,irad_panel_hour);                          %W*h
Energy_Generated_panel1 = area4/(1000*60);                      %Total Energy generated by 1 panel in kWh
Energy_Generated_system1 = Energy_Generated_panel1*Num_panels;  %Total Energy generated by entire system in kWh

%Plot to see full array power over hours
% figure
% plot(hours1, irad_panel_hour.*Num_panels./(60*1000))
% hold
% title("Power over Time")
% xlabel("Time (hours)")
% ylabel("System (kW)")

fprintf('The number of panels needed is about %d\n', Num_panels);
fprintf('The system will generate about %.2f kWh on this day\n', Energy_Generated_system);

%% Load Modeling
DailyLoad = input('What is your Estimated Daily Consumption (kWh/day)?');  %Get from Excel Sheet
%Uncomment which load profile you want to use and comment out the others
%% Resiliency
%User inputs an estimate of how much of their load they would like to be resilient
CriticalLoad_Percentage = input('What Percentage of your load is critical?');  %Get from Excel Sheet
CriticalLoad = CriticalLoad_Percentage/100 * DailyLoad;     %Sets Resilient Load Requirement
%% Flat Load 8h
%Flat Load 8h - Constant Load over 8h period
%Default starts at 9am
x4 = 1000*CriticalLoad/8;                     %constant load per minute in Watts: kWh*1000W/kW * 1day/8h
Load_Flat4 = zeros(1,length(minutes));        %Create array of load power across minutes
SoD = 9;                                      %Start of Day - hour - use 24h range - does not wrap so cannot exceed 16
SoD_min = SoD*60;
for i = 1:481
    Load_Flat4(SoD_min+i) = x4;     %Fill Load array with constant load amount centered starting at 9am = 540min
                                    %Fill for 8h = 480min
end
CriticalLoad_Check = (trapz(minutes,Load_Flat4)-x4)/1000/60;  %Load Check, Should equal CriticalLoad
%% Flat Load 12h
% %Flat Load 12h - Constant Load over 12h period
% %Default starts at 6am
% x4 = 1000*CriticalLoad/12;                    %constant load per minute in Watts: kWh*1000W/kW * 1day/12h
% Load_Flat4 = zeros(1,length(minutes));        %Create array of load power across minutes
% SoD = 6;                                      %Start of Day - hour - use 24h range - does not wrap so cannot exceed 12
% SoD_min = SoD*60;
% for i = 1:721
%     Load_Flat4(SoD_min+i) = x4;     %Fill Load array with constant load amount centered starting at 9am = 540min
%                                     %Fill for 12h = 720min
% end
% CriticalLoad_Check = (trapz(minutes,Load_Flat4)-x4)/1000/60;  %Load Check, Should equal CriticalLoad
%% Flat Load 24h
%Flat Load 24h - Constant Load over 24h period

% x4 = 1000*CriticalLoad/24;                  %W
% Load_Flat4 = zeros(1,length(minutes));      %Create array of daily load across minutes
% for i = 1:length(minutes)
%     Load_Flat4(i) = x4;                     %Fill Load array with constant load amount                         
% end
% CriticalLoad_Check = (trapz(minutes,Load_Flat4)-x4)/1000/60;
%% Plot Solar Gen vs Resilient Load over Minutes
% figure
% plot(minutes, Load_Flat4); M4 = "Load";
% hold on
% plot(minutes, irad_panel.*Num_panels); M5 = "Solar Generation";
% hold off
% title("Power vs. Time")
% xlabel("Time (minutes)")
% ylabel("Power (W)")
% legend(M4,M5)
%% Load in Hours
%Transforms Load plots and arrays to fit over an Hours axis

x5 = CriticalLoad/(8);                  %kW
Load_Flat5 = zeros(1,length(hours1));   %Creates Load array for hours axis
for i = 1:9
    Load_Flat5(9+i) = x5;               %Fill Load array with constant load amount starting at 9am 
end
CriticalLoad_CheckHours = trapz(hours1,Load_Flat5)-x5;       %Load Check, Should equal CriticalLoad
%% Plot Solar Gen vs Resilient Load over Hours
% figure
% plot(hours1, Load_Flat5); M6 = "Load";
% hold on
% plot(hours1, irad_panel_hour.*Num_panels./(60*1000)); M7 = "Full System";
% hold off
% title("Power vs. Time")
% xlabel("Time (hours)")
% ylabel("Power (kW)")
% legend(M6,M7)

%% Battery Modeling
BatteryMargin = 1;  %Used to scale the battery capacity
c = 1;              %Loop check variable
check = 0;          %Battery capacity check variable
while c == 1        %Keeps increasing the battery capacity until the net energy = 0 at all points
%% Energy Difference
%Energy difference must look at Areas - Power*Time - W*min - Battery needs kWh

TotalSolarPower = irad_panel.*Num_panels;           %array gen for the day over minutes
%Area under TotalSolarPower
SolarEnergy = cumtrapz(minutes, TotalSolarPower); %Total Energy generated in W*min

%Area per minute of TotalSolarPanel
SolarEnergy_Areas = zeros( 1,length(minutes) );
for i=1:(length(minutes)-1)
    SolarEnergy_Areas(i) = SolarEnergy(i+1) - SolarEnergy(i);
    %Calculates Total Area 1 minute ahead and subtracts the Area of 1 minute behind
    %SolarEnergy_Areas is filled with the area of 1 minute sections across the day
    %Units would be W*min
end

%Area under Load
LoadEnergy = cumtrapz(minutes, Load_Flat4); %Total Energy generated in W*min
%Will need to change Load variable based on which Load type you want to use

%Area per minute of Load
LoadEnergy_Areas = zeros( 1,length(minutes) );
for i=1:(length(minutes)-1)
    LoadEnergy_Areas(i) = LoadEnergy(i+1) - LoadEnergy(i);
    %Same concept as SolarEnergyAreas
end

EnergyDifference = SolarEnergy_Areas - LoadEnergy_Areas;
%Difference in Energy b/t Solar Gen and Load
%positive difference = Gen>Load battery could charge during this time 
%negative difference - Load>Gen and battery would need to supply the difference

%Find all Positive Difference Amounts
pos = max(0, EnergyDifference);         %Go through EnergyDifference array and only find positive values
[row col] = find(EnergyDifference>0);   %Will return row and coloumn values where postive values are
Excess_Energy = sum(pos)/60/1000;       %Sum up all positive values (W*min) and change to kWh
%This value represents solar generation that is not being used in a resilient condition

%Find all Negative Difference Amounts
neg = min(0, EnergyDifference);         %Go through EnergyDifference array and only find negative values
[row2 col2] = find(EnergyDifference<0); %Will return row and coloumn values where negative values are
Needed_Energy = sum(neg)/60/1000*-1;    %Sum up all negative values (W*min) and change to kWh
%This value represents Load Energy that is not being met by Solar Gen in a resilient condition
%% Battery Capacity Modeling

%Size battery based on how much energy is not being met by solar generation

BatteryCapacity = BatteryMargin*Needed_Energy; %kWh
BatteryCharge = zeros(1,length(minutes) );
SoC_Initial = .5;      %Initial State of Charge of Battery when Day begins
SoC_Min = .2;          %Minimum State of Charge Battery can be discharged to

%Energy difference is in W*m so need to convert charge to W*min
BatteryCharge(1) = 1000*60*BatteryCapacity*SoC_Initial;             %Begins the battery charge at SoC
for i=1:(length(minutes)-1)
    BatteryCharge(i+1) = BatteryCharge(i) + EnergyDifference(i);    %Battery charge will equal the previous charge plus the energy difference between the load and solar gen
    if(BatteryCharge(i+1) > (1000*60*BatteryCapacity))              %check if the charge has hit the battery capacity
        BatteryCharge(i+1) = 1000*60*BatteryCapacity;               %if the charge is greater than the capacity, battery will not charge anymore
%         check = 1;                                                  %If battery needs to contain all the solar generation leave this check uncommented
%         break                                                       %will keep increasing the capacity untill the charge does not max out
    elseif(BatteryCharge(i) < 1000*60*BatteryCapacity*SoC_Min)      %Check if charge dips below the minimum SoC (20% capacity)
        BatteryCharge(i+1) = 1000*60*BatteryCapacity*SoC_Min;       %if charge is less than the minimum stay at the minimum
        check = 1;                                                  %increase capacity until charge does not dip below minimum when load needs it
        break
    else
     check = 0;                                                     %When both the max and min checks are okay while loop ends
    end
end
BatteryCharge = BatteryCharge/60/1000;  %Convert to kWh                              
%% Grid Modeling
%Models the grid power - assuming outage is the full day the grid line should be 0 all day
%If assuming excess solar energy can be fed back into the grid then the grid will be negative to represent energy fed back
Grid_Power = zeros(1,length(minutes) );
for i=1:(length(minutes)-1)
    if(BatteryCharge(i) >= BatteryCapacity )    %Check when the charge is full
        Grid_Power(i) = -EnergyDifference(i);   %if full then feed the excess energy to the grid
    end
end
%% Rate of Charge/Discharge
%Calculates the power rating needed from the battery
BatteryRate = zeros(1,length(minutes) );
for i=1:(length(minutes)-1)
    %calculates the slope of the charge plot at all times
    %the slope of the charge/capacuity is the power 
    BatteryRate(i) = (BatteryCharge(i+1) - BatteryCharge(i))*60;
    %y2-y1/x2-x1 = y2-y1/1min *60min/1h
end
%Find the max charge and discharge - max positive and negative slope
PeakCharge = max(BatteryRate);
PeakDischarge = min(BatteryRate)*-1;
PeakPowerRating = max(PeakCharge,PeakDischarge);    %Power rating is the bigger of the charge or discharge rate
%% Battery Check
%If any checks came on in the battery capacity modeling then increase the capacity of the battery and try again
%If no checks came on then end the loop and output the final plot and capacity estimation
if (check == 1)
    BatteryMargin = BatteryMargin+.1;
else
    c = 0;
end
end
fprintf('The battery will need at least %.1f kWh capacity\n', BatteryCapacity);
fprintf('The battery will need a continuous power rating of at least %.1f kW\n', PeakPowerRating);
%% Plot Load Consumption, Solar Gen, Grid and Battery Capacity (Power vs. Time)
figure
yyaxis left
plot(minutes, Load_Flat4/60/1000); M7 = "Load";
hold on
plot(minutes, irad_panel.*Num_panels/60/1000); M8 = "Solar Generation";
hold on
plot(minutes, Grid_Power/60/1000); M9 = "Grid";
hold on
ylabel("Power (kW)")
yyaxis right
plot(minutes, BatteryCharge); M10 = "Battery";
hold off
ylabel("Battery Capacity (kWh)")
title("Solar Gen, Critical Load Consumption, Grid and Battery Capacity vs. Time")
xlabel("Time (minutes)")
legend(M7,M8,M9,M10)
